// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod server {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum PackageKind {
  RequestLogin = 0,
  ResponseLogin = 1,
  RequestChange = 2,
  ResponseChange = 3,

}

const ENUM_MIN_PACKAGE_KIND: i8 = 0;
const ENUM_MAX_PACKAGE_KIND: i8 = 3;

impl<'a> flatbuffers::Follow<'a> for PackageKind {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for PackageKind {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const PackageKind;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const PackageKind;
    unsafe { *p }
  }
}

impl flatbuffers::Push for PackageKind {
    type Output = PackageKind;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<PackageKind>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_PACKAGE_KIND:[PackageKind; 4] = [
  PackageKind::RequestLogin,
  PackageKind::ResponseLogin,
  PackageKind::RequestChange,
  PackageKind::ResponseChange
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_PACKAGE_KIND:[&'static str; 4] = [
    "RequestLogin",
    "ResponseLogin",
    "RequestChange",
    "ResponseChange"
];

pub fn enum_name_package_kind(e: PackageKind) -> &'static str {
  let index = e as i8;
  ENUM_NAMES_PACKAGE_KIND[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(u16)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum ChangeKind {
  Spawn = 0,
  Pos = 1,
  GenericU32 = 2,
  GenericI32 = 3,
  GenericStr = 4,
  GenericF32 = 5,

}

const ENUM_MIN_CHANGE_KIND: u16 = 0;
const ENUM_MAX_CHANGE_KIND: u16 = 5;

impl<'a> flatbuffers::Follow<'a> for ChangeKind {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for ChangeKind {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u16::to_le(self as u16);
    let p = &n as *const u16 as *const ChangeKind;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u16::from_le(self as u16);
    let p = &n as *const u16 as *const ChangeKind;
    unsafe { *p }
  }
}

impl flatbuffers::Push for ChangeKind {
    type Output = ChangeKind;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<ChangeKind>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_CHANGE_KIND:[ChangeKind; 6] = [
  ChangeKind::Spawn,
  ChangeKind::Pos,
  ChangeKind::GenericU32,
  ChangeKind::GenericI32,
  ChangeKind::GenericStr,
  ChangeKind::GenericF32
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_CHANGE_KIND:[&'static str; 6] = [
    "Spawn",
    "Pos",
    "GenericU32",
    "GenericI32",
    "GenericStr",
    "GenericF32"
];

pub fn enum_name_change_kind(e: ChangeKind) -> &'static str {
  let index = e as u16;
  ENUM_NAMES_CHANGE_KIND[index as usize]
}

}  // pub mod server

