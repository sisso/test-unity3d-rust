// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod ffi_packages {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u16)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum PackageKind {
  Request = 0,
  Response = 1,

}

const ENUM_MIN_PACKAGE_KIND: u16 = 0;
const ENUM_MAX_PACKAGE_KIND: u16 = 1;

impl<'a> flatbuffers::Follow<'a> for PackageKind {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for PackageKind {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u16::to_le(self as u16);
    let p = &n as *const u16 as *const PackageKind;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u16::from_le(self as u16);
    let p = &n as *const u16 as *const PackageKind;
    unsafe { *p }
  }
}

impl flatbuffers::Push for PackageKind {
    type Output = PackageKind;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<PackageKind>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_PACKAGE_KIND:[PackageKind; 2] = [
  PackageKind::Request,
  PackageKind::Response
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_PACKAGE_KIND:[&'static str; 2] = [
    "Request",
    "Response"
];

pub fn enum_name_package_kind(e: PackageKind) -> &'static str {
  let index = e as u16;
  ENUM_NAMES_PACKAGE_KIND[index as usize]
}

}  // pub mod FfiPackages

